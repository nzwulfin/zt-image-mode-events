= Building your own base images

There are times that you want to create your own bases from scratch instead of relying on the Red Hat base images. Here's how to do that.

[#write-containerfiles]
== Building from scratch

Just like any other container image, bootc images can start from an empty filesystem. 
We use the Red Hat base as the builder, since the tools needed to create a rootfs that bootc can use are build into bootc.

Let's explore how that can work by creating a new Containerfile with the following contents.
[source,bash,role="execute",subs=attributes+]
----
nano Containerfile.scratch
----
scratch build with standard packages and configs
[source,dockerfile,role="execute",subs=attributes+]
----
# Begin with a standard bootc base image that serves as a "builder" for our custom image.
FROM registry.redhat.io/rhel10/rhel-bootc:10.1 AS builder
# Build the root file system by using the specified repositories and non-RPM content from the "builder" base image.
# If no repositories are defined, the default build will be used. You can modify the scope of packages in the base image by changing the manifest between the "standard" and "minimal" sets.
RUN /usr/libexec/bootc-base-imagectl build-rootfs --manifest=standard /target-rootfs

# Create a new, empty image from scratch.
FROM scratch
# Copy the root file system built in the previous step into this image.
COPY --from=builder /target-rootfs/ /

# Apply customizations to the image.
RUN <<EORUN
set -xeuo pipefail
# Install necessary packages, run scripts, etc.
dnf -y install NetworkManager emacs
# Remove leftover build artifacts from installing packages in the final built image.
dnf clean all
rm /var/{log,cache,lib}/* -rf
EORUN

# Define required labels for this bootc image to be recognized as such.
LABEL containers.bootc 1
LABEL ostree.bootable 1

# Optional labels that only apply when running this image as a container. These keep the default entry point running under systemd.
STOPSIGNAL SIGRTMIN+3
CMD ["/sbin/init"]

# Run the bootc linter to avoid encountering certain bugs and maintain content quality. Place this command last in your Containerfile.
RUN bootc container lint
----
podman build -t scratch -f Containerfile.scratch --cap-add=all --security-opt=label=type:container_runtime_t --device /dev/fuse

You can see that seemingly simple builder image does a huge amount of work setting up the base filesystem.
It also installed 400+ packages, since this is the specification for the standard base image RHT ships.
We also provide a minimal manifest that has even fewer packages selected. 
[source,dockerfile,role="execute",subs=attributes+]
----
# Begin with a standard bootc base image that is reused as a "builder" for the custom image.
FROM registry.redhat.io/rhel10/rhel-bootc:10.1 AS builder
# Build the root file system by using the specified repositories and non-RPM content from the "builder" base image.
RUN /usr/libexec/bootc-base-imagectl build-rootfs --manifest=minimal /target-rootfs

# Create a new, empty image from scratch.
FROM scratch
COPY --from=builder /target-rootfs/ /

RUN <<EORUN
set -xeuo pipefail
dnf -y install NetworkManager openssh-server
dnf clean all
rm /var/{log,cache,lib}/* -rf
bootc container lint
EORUN

# Define required labels for this bootc image to be recognized as such.
LABEL containers.bootc 1
LABEL ostree.bootable 1

STOPSIGNAL SIGRTMIN+3
CMD ["/sbin/init"]

RUN bootc container lint
----

The manifests are part of the base image definitions[https://gitlab.com/fedora/bootc/base-images/-/tree/main?ref_type=heads,window=_blank]

